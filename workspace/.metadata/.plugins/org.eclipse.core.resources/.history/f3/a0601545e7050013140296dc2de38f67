/**
 * Copyright 2012-2013 University Of Southern California
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package mac499.planning;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Random;

import org.cloudbus.cloudsim.Log;
import org.workflowsim.CondorVM;
import org.workflowsim.Task;
import org.workflowsim.planning.BasePlanner;

/**
 * The Random planning algorithm.
 * 
 * @author Weiwei Chen
 * @since WorkflowSim Toolkit 1.0
 * @date Jun 17, 2013
 */
public class HEFTPlanner extends BasePlanner {

	private Map<Task, Map<CondorVM, Integer>> costs;

	public HEFTPlanner() {
		costs = new HashMap<>();
	}

	/**
	 * The main function
	 */
	@Override
	public void run() {
		Log.printLine("HEFT planner running with " + getTaskList().size()
				+ " tasks.");

		calculateComputationCosts();
		// if(false)
		// return;
		//
		// for (Iterator it = getTaskList().iterator(); it.hasNext();) {
		// Task task = (Task) it.next();
		// double duration = task.getCloudletLength() / 1000;
		//
		// for(int i = 0; i < task.getParentList().size(); i++ ){
		// Task parent = task.getParentList().get(i);
		// }
		//
		//
		// for(int i = 0; i < task.getChildList().size(); i++ ){
		// Task child = task.getChildList().get(i);
		// }
		//
		// int vmNum = getVmList().size();
		// /**
		// * Randomly choose a vm
		// */
		// Random random = new Random((long)duration);
		// int vmId = random.nextInt(vmNum);
		//
		// CondorVM vm = (CondorVM) getVmList().get(vmId);
		// //This shows the cpu capability of a vm
		// double mips = vm.getMips();
		//
		// task.setVmId(vm.getId());
		//
		//
		//
		// }
		// }

	}

	private void calculateComputationCosts() {
		for (Object vmObject : getVmList()) {
			CondorVM vm = (CondorVM) vmObject;
			for (Object taskObject : getTaskList()) {
				Task task = (Task) taskObject;
				Map<CondorVM,Integer> costsVm = new HashMap<CondorVM,Integer>();
				
				if(vm.getNumberOfPes() < task.getNumberOfPes()){
					costsVm.put(vm, Integer.MAX_VALUE);
					continue;
				}
				System.out.println(task.getCostPerSec(0));
//				costsVm.put(vm, task.getCloudletTotalLength() * 1/vm.getMips() * vm.getId());
//				System.out.println(task.getNumberOfPes());
//				System.out.println(vm.getNumberOfPes());
			}
		}
	}
	
}
